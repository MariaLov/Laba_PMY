# Laba_PMY
***
# Колисниченко "Программирование для Android" (стр.156-162)
***

Нарисовать прямоугольник с закругленными углами (```RoundRectShape```) сложнее.
Конструктор ```RoundRectShape``` выглядит так:

```Java
RoundRectShape(float[] outerRad, RectF inset, float[] innerRad) 
```

Рассмотрим параметры этого конструктора:
- ```outerRad``` - массив из восьми значений радиуса закругления углов внешнего
  прямоугольника. Первые два значения соответствуют верхнему левому углу,
  вторые - верхнему правому, третьи - нижнему правому, четвертые - нижнему левому;
- ```inset``` - объект класса ```RectF```, определяет расстояние от внутреннего прямоугольника до каждой стороны внешнего прямоугольника. Конструктор объекта
  ```RectF``` принимает четыре параметра: пары Х и У координат левого верхнего и
  правого нижнего углов внутреннего прямоугольника; 
- ```innerRad``` - массив из восьми значений радиуса закругления углов внутреннего
  прямоугольника. Пары значений такие же, как в случае с ```outerRad```, а если на
  внутреннем прямоугольнике закруглений не предусмотрено, передается ```null```. 

Пример:
```Java
float [] oR = new float [] { 5, 5, 5, 5, 5, 5, 5, 5 1};
float [] iR = new float [] { 5, 5, 5, 5, 5, 5, 5, 5 1};
RectF rf = new RectF(B, в, в, В);

// создаем фигуру (RoundRect)
ShapeDrawaЬle shape = new ShapeDrawaЫe(new RoundRectShape(oR, rf, iR));
// устанавливаем высоту и ширину
shape.setintrinsicHeight(150);
shape.setintrinsicWidth(200);
// устанавливаем цвет - красный
shape.getPaint().setColor(Color.RED); 
```
Класс ```Path``` используется для создания множественного контура (пригодится для
построения графов и других фигур сложной формы), состоящего из линий, квадратичньrх и кубических кривых. Для установки точек используется метод ```moveTo ()```,
а для создания линий - метод ```lineTo ()```, параметры метода - это координаты
конечной точки линии, а координаты начальной точки задаются методом ```moveTo ()```.

Вот пример использования класса ```Path```:
```Java
Path р = new Path();
p.rnoveTo(б0, О);
p.lineTo(l00,150);
p.lineTo(200,250);
ShapeDrawaЬle shape = new ShapeDrawaЬle(new PathSpahe(p, 100, 100));
shape.setintrinsicHeight(200);
shape.setintrinsicWidth(250);
shape.getPaint() .setColor(Color.GREEN);
```
Класс ```ArcShape ()``` используется для создания дуги. Его конструктор принимает два
параметра типа ```float```. Первый из них задает угол начала прорисовки дуги в градусах, а второй - угловой размер дуги, тоже в градусах:

```Java
ArcShape (float startAngle, float sweepAngle); 
```
***

В следующей главе мы поговорим о работе с мультимедиа, а к рисованию еще вернемся в *главе 14*, когда будем рассматривать анимацию. 


## <img alt="img.png" height="65" src="img_1.png" width="65"/> ГЛАВА 7  


# Мультимедиа
## 7.1. Форматы мультимедиа, поддерживаемые ОС Android ##

В предыдущей главе была рассмотрена поддержка графических форматов, и вы узнали, что Android поддерживает популярные форматы JPG, GIF и PNG. В этой главе мы поговорим о поддержке аудио- и видеоформатов. Android поддерживает
практически все популярные мультимедиаформаты: МРЗ, МР4, FLAC, ЛАС, OGG
и ряд даже не очень популярных. Поддерживаемые аудио/видеоформаты представлены в табл. 7.1. 

<p align="right"><b>Таблица 7.1.</b> Поддерживаемые аудио/видеоформаты<p/> 
<table>
    <thead>
        <tr>
            <th>Тип мультимедиа</th>
            <th>Сжатие</th>
            <th>Поддерживаемые действия</th>
            <th>Форматы</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td rowspan=2 align="left">Видео</td>
            <td rowspan=1 align="left">Почти без потерь</td>
            <td rowspan=1 align="left">Воспроизведение</td>
            <td align="left">H.264</td>
        </tr>
        <tr>
            <td align="left">С минимальными потерями</td>
            <td align="left">Запись/воспроизведение</td>
            <td align="left">H.263, MPEG-4 SP</td>
        </tr>
        <tr>
            <td rowspan=5 align="left">Аудио (музыка)</td>
            <td rowspan=1 align="left">Без сжатия</td>
            <td rowspan=1 align="left">Запись/воспроизведения</td>
            <td align="left">PCM</td>
        </tr>
        <tr>
            <td align="left">Без сжатия</td>
            <td align="left">Воспроизведение</td>
            <td align="left">WAVE</td>
        </tr>
        <tr>
            <td align="left">Без потерь</td>
            <td align="left">Не поддерживается</td>
            <td align="left">FLAC</td>
        </tr>
        <tr>
            <td align="left">С минимальными потерями</td>
            <td align="left">воспроизведение</td>
            <td align="left">MP3, MP4, OGG, AAC, HE-AACv1, HE-AACv2</td>
        </tr>
        <tr>
            <td align="left">Midi</td>
            <td align="left">Воспроизведение</td>
            <td align="left">MID, RXT, XMF, OTA, IMY, RTTTL</td>
        </tr>
        <tr>
            <td rowspan=2 align="left">Аудио (речь)</td>
            <td rowspan=1 align="left">С минимальными потерями</td>
            <td rowspan=1 align="left">Запись/воспроизведения</td>
            <td align="left">AMR-NB</td>
        </tr>
        <tr>
            <td align="left">С минимальными потерями</td>
            <td align="left">Воспроизведение</td>
            <td align="left">AMR-WB</td>
        </tr>
        <tr>
        </tr>
    </tbody>
</table>

Если в вашем приложении планируется запись аудио или видео, то в файл манифеста нужно добавить соответствующие разрешения:
```Java
<uses-perrni.ssion android:name="android.permission.RECORD_AUDIO"/>
<uses-permission android:name="android.permission.RECORD_VIDEO"/> 
```

> ***Примечание***
> 
> Ранее было сказано, что в Android 6 некоторые возможности - например, номер
уровня API - «переехали» из файла манифеста в Gradle Scripts. Так вот, разрешений
это не коснулось, и они все еще определяются в файле манифеста.

## 7.2. Работа со звуком ##

Существуют два различных способа записи и воспроизведения аудиороликов:
- ```MediaPlayer/MediaRecorder``` - классы, обеспечивающие стандартный метод работы со звуком. Звук при этом либо хранится в файле, либо может быть представлен как потоковые данные. Для обработки аудио создается отдельный
  поток;
- ```AudioTrack/AudioRecorder``` - прямой (raw) доступ к аудиоданным. Полезен при
  манипуляциях со звуком в памяти, записи звука в буфер при воспроизведении
  или в любых других случаях, не требующих наличия потока или файла. Оrдельный поток при обработке звука не создается. 

## 7.2.1. Изпользуем MediaPlayer ##

Рассмотрим, как можно воспроизвести звук с помощью класса MediaPlayer. Подключается он так:
``` Java
import android.rnedia.MediaPlayer; 
```
Затем создать экземпляр ```MediaPlayer```: 
```Java
MediaPlayer music = new MediaPlayer(); 
```
После этого указываем источник звука (в нашем случае это будет RAW-pecypc) и
загружаем звуковой файл: 
```Java
music = MediaPlayer.create(this, R.raw.musicl);
music.setDataSource(path);
music.prepare(); 
```
Выполнив все подготовительные работы, запускаем воспроизведение методом
```start ()```:
```Java
music.start(); 
```

Метод ```pause()``` приостанавливает воспроизведение, продолжить воспроизведение
можно снова методом ```start ()``` :
```Java
music.pause(); 
music.start();
```
Остановить воспроизведение и освободить ресурсы можно методами ```stop()``` и
```release()``` соответственно: 
```Java
music.stop();    // останавливаем воспроизведение 
music.release(); // освобождаем ресурсы 
```
Класс ```MediaPlayer``` подцерживает воспроизведение не только с локального устройства. Можно воспроизводить музыку, которая находится на удаленном сервере, например: 

```Java
final String DАТА_НТГР = "http://exarnple.com/music.mp3"; 
final' String DATA_STREAМ = "http://online.example.com:810l/rr_128"; 
mediaPlayer = new MediaPlayer(); 
mediaPlayer.setDataSource(DATA_HTTP); 
mediaPlayer.setAudioStrearnType(Audioмanager.STREAМ_МUSIC); 
mediaPlayer.setOnPreparedListener(this); 
mediaPlayer.prepareAsync(); 
```
Аналогично можно запустить воспроизведение потокового аудио: 

```Java
mediaPlayer = new MediaPlayer(); 
mediaPlayer.setDataSource(DATA_STREAМ); 
mediaPlayer.setAudioStreamТype(Audioмanager.STREAМ_МUSIC); 
mediaPlayer.setOnPreparedListener(this); 
mediaPlayer.prepareAsync(); 
```
## 7.2.2. Изпользуем MediaRecorder: запись звука ##

Прежде, чем приступить к записи звука, нужно определиться с его источником
(свойство ```MediaRecorder.AudioSource```): 
- ```MIC``` - встроенный микрофон; 
- ```VOICE_UPLINК``` - исходящий голосовой поток при телефонном звонке (то, что вы
  говорите); 
- ```VOICE_DOWNLINК```- входящий голосовой поток при телефонном звонке (то, что
  говориr ваш собеседник);
- ```VOICE_CALL``` - запись телефоmюго звонка;
- ```CAМCORDER``` - микрофон, связанный с камерой, если таковой доступен;
- ```VOICE_RECOGNITION``` - микрофон, используемый для распознавания голоса, если таковой доступен.

После выбора источника звука нужно задать формат записываемого звука (свойство ```MediaRecorder.OutputFormat```):
- ```ТНRЕЕ_GPP``` - формат ЗGРР;
- ```MPEG_4``` - формат МРЕG4;
- ```АМR_NB``` - формат АМR _ NВ, лучше всего подходит для речи.

Рассмотрим последовательность действий для записи звука:
1. Создание экземпляра ```MediaRecorder```.
2. Указание источника звука - например, микрофона.
3. Установка результирующего формата и сжатия звука.
4. Установка пути к файлу, в котором будет сохранен звук.
5. Подготовка и запуск записи.
6. Остановка записи. 

Далее приведен код для каждого из этих этапов:
```Java
// 1 
MediaRecorder record = new MediaRecorder(); 
// 2 
record.setAudioSource(MediaRecorder.AudioSource.MIC); 
// з 
record.setOutputFoпnat(MediaRecorder.OutputFoпnat.AМR_NВ); 
record.setAudioEncoder(MediaRecorder.AudioEncoder.AМR_NВ); 
// 4 
record.setOutputFile(path); 
// 5 
record.prepare(); 
record.start(); 
// 6 
record. stop () ;
```
Для поддержки ```MediaRecorder``` нужно подключить следующий пакет:
```Java
import android.media.MediaRecorder;
```
## 7.2.3. Изпользование AudioRecord и AudioTrack ##

Возможностей ```MediaPlayer/Media.Recorder``` в большинстве случаев должно хватить .
Но для манипуляции прямыми (raw) аудиоданными, полученными, например, непосредственно из микрофона, нужно использовать классы ```AudioRecord``` и ```AudioTrack```.
Первый класс служит для записи звука, второй - для его воспроизведения.
Для непосредственной манипуляции со звуком вам нужно подключить следующие
пакеты:
```Java
import android.media.AudioFormat; 
import android.media.AudioManager; 
import android.media.AudioRecord; 
import android.media.AudioTrack; 
import android.media.MediaRecorder;
```

Чтобы приложение могло записывать данные с помощью ```AudioRecord```, надо в файле
манифеста объявить соответствующее разрешение: 
```Java
<uses-permission android:name="android.permission.RECORD_AUDIO" /> 
```
Теперь рассмотрим процесс записи с помощью ```AudioRecord```. Прежде всего нужно
создать экземпляр ```AudioRecord``` и установить источник звука: 
```Java
short [] Audiol = new short [10000]; 
AudioRecord audioRecord = new AudioRecord( 
MediaRecorder.AudioSource.MIC, 11025, 
AudioFormat.CНANNEL_IN_MONO, 
AudioFormat.ENCODING_PCМ_lбBIT, 10000);
```
Наша конфигурация подходит для записи голоса со встроенного микрофона в
буфер ```myAudio```. Мы записываем 11 025 образцов в секунду, а размер буфера -
10 000 образцов, следовательно, длительность записи - менее секунды. Для более
длительной записи нужно увеличить размер буфера.
- Первый параметр - это источник звука. Вы можете использовать свойство
  ```MediaRecorder.AudioSource``` для указания источника звука.
- Второй параметр (11 025) - это частота звука (в Гц). Такая частота подходит только для записи голоса, для СD-качества необходима частота 44 100.
- Мы записываем монозвук, для записи стерео измените третий параметр - его
  значение должно выглядеть так: ```AudioFormat.CНANNEL_IN_STEREO```.
- Кодирование звука задается четвертым параметром. Здесь мы можем использовать либо 16-битное кодирование (что мы и делаем), либо 8-битное
  (```AudioFormat.ENCODING_РCM_8BIT```).
- Последний параметр - это размер буфера в байтах, в который будет производиться запись. Другими словами - это общий размер выделенной памяти. Для
   правильного задания этого параметра лучше бьmо бы воспользоваться методом
   ```getMinBufferSize()```, но для упрощения примера мы указали значение в байтах.
  
Далее нужно начать запись: 

```Java
audioRecord.startRecording();
```

Поскольку у нас прямой доступ к микрофону, то просто указать файл, в который
нужно поместить прочитанный звук, нельзя. Нужно еще вручную считать этот звук
с микрофона. Для этого используется метод ```read()``` : 
```Java
audioRecord.read(Audiol, О, 10000);
```

Остановить запись можно методом ```stop()```:
```Java
audioRecord.stop(); 
```

Теперь поговорим о воспроизведении звука средствами ```AudioTrack```. Конструктору
объекта ```AudioTrack``` нужно передать:
- тип потока: ```AudioManager.STREAМ_MUSIC``` (микрофон) или ```STREAМ_VOICE_CALL``` (голосовой звонок). Другие варианты используются реже;
- частоту в герцах - значения такие же, как и для записи звука;
- конфигурацию канала: ```AudioFormat.CНANNEL_OUT_STEREO``` или ```AudioFormat.CНANNEL_OUT_MONO```. Можно также использовать значение ```CНANNEL_OUT_5POINT1``` для звука 5.1;